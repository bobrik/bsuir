/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * HyperNothingGUI.java
 *
 * Created on 21.02.2010, 15:48:29
 */
package hypernothing;

import java.awt.*;

import javax.swing.*;
import javax.swing.text.*;

import java.io.*;
import java.util.*;

/**
 * Main application class for GUI handling
 * @author bobrik
 */
public class HyperNothingGUI extends javax.swing.JFrame
{
    /**
     * Directory of the system
     */
    private String directory;

    /**
     * Extension of the system files
     */
    private String extension = ".nothing";

    /**
     * Link style attribute
     */
    private Object linkStyle = StyleConstants.Background;

    /**
     * Link style attribute value
     */
    private Color linkStyleValue = Color.red;
    
    /**
     * Current system document
     */
    private AbstractDocument doc;

    /** 
     * Creates new form HyperNothingGUI
     */
    public HyperNothingGUI() {
	initComponents();

	StyledDocument styledDoc = textPane.getStyledDocument();

	if (styledDoc instanceof AbstractDocument) {
	    doc = (AbstractDocument) styledDoc;
	} else {
	    System.err.println("Text pane's document isn't an AbstractDocument!");
	    System.exit(-1);
	}

	changeLocation();
    }

    /**
     * This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        verticesLabel = new javax.swing.JLabel();
        startVertexField = new javax.swing.JTextField();
        endVertexField = new javax.swing.JTextField();
        calculateMaxPathButton = new javax.swing.JButton();
        scrollPane = new javax.swing.JScrollPane();
        textPane = new javax.swing.JTextPane();
        changeLocationButton = new javax.swing.JButton();
        jSeparator1 = new javax.swing.JSeparator();
        jLabel1 = new javax.swing.JLabel();
        searchField = new javax.swing.JTextField();
        searchButton = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("HyperNothing");
        setMinimumSize(new java.awt.Dimension(620, 350));
        setName("hyperNothingFrame"); // NOI18N

        verticesLabel.setText("Vertices:");

        startVertexField.setText("index");
        startVertexField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                startVertexFieldActionPerformed(evt);
            }
        });

        endVertexField.setText("end");
        endVertexField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                endVertexFieldActionPerformed(evt);
            }
        });

        calculateMaxPathButton.setText("Calculate max path");
        calculateMaxPathButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                calculateMaxPathButtonActionPerformed(evt);
            }
        });

        textPane.setEditable(false);
        textPane.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                textPaneMouseClicked(evt);
            }
        });
        scrollPane.setViewportView(textPane);

        changeLocationButton.setText("Change location");
        changeLocationButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                changeLocationButtonActionPerformed(evt);
            }
        });

        jSeparator1.setOrientation(javax.swing.SwingConstants.VERTICAL);

        jLabel1.setText("Search:");

        searchField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                searchFieldActionPerformed(evt);
            }
        });

        searchButton.setText("Search");
        searchButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                searchButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(scrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 596, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(changeLocationButton, javax.swing.GroupLayout.PREFERRED_SIZE, 140, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(verticesLabel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(startVertexField, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(endVertexField, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(calculateMaxPathButton))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(searchField, javax.swing.GroupLayout.PREFERRED_SIZE, 174, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(searchButton)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(changeLocationButton)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(verticesLabel)
                        .addComponent(startVertexField, javax.swing.GroupLayout.PREFERRED_SIZE, 22, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(endVertexField, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(calculateMaxPathButton))
                    .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(12, 12, 12)
                .addComponent(scrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 274, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(searchField, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(searchButton))
                .addGap(16, 16, 16))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Event handler for searchVertexField action performing
     * @param evt
     */
    private void startVertexFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_startVertexFieldActionPerformed
	// TODO add your handling code here:
	calculateMaxPathButtonActionPerformed(evt);
    }//GEN-LAST:event_startVertexFieldActionPerformed

    /**
     * Check if character at current carret position after click is part of link
     * and initiate link opening if successed with link checking
     * @param evt
     */
    private void textPaneMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_textPaneMouseClicked
	// TODO add your handling code here:
	try {
	    doc.getText(textPane.getCaretPosition(), 1);
	    AttributeSet attrs = textPane.getCharacterAttributes();
	    boolean isLink = false;
	    if (attrs.containsAttribute(linkStyle, linkStyleValue)) {
		isLink = true;

		while (textPane.getCharacterAttributes().containsAttribute(linkStyle, linkStyleValue)) {
		    textPane.setCaretPosition(textPane.getCaretPosition() - 1);
		}
		textPane.setCaretPosition(textPane.getCaretPosition() + 1);

		int linkStartPosition = textPane.getCaretPosition();
		int linkLength = 0;

		while (textPane.getCharacterAttributes().containsAttribute(linkStyle, linkStyleValue)) {
		    textPane.setCaretPosition(textPane.getCaretPosition() + 1);
		    ++linkLength;
		}

		if (isLink) {
		    openNothing(doc.getText(linkStartPosition, linkLength));
		}
	    }
	} catch (BadLocationException ex) {
	}
    }//GEN-LAST:event_textPaneMouseClicked

    /**
     * Change event handler for changeLocationButton
     * @param evt
     */
    private void changeLocationButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_changeLocationButtonActionPerformed
	// TODO add your handling code here:
	changeLocation();
    }//GEN-LAST:event_changeLocationButtonActionPerformed

    /**
     * Search path length at calculateMaxPathButton action performing
     * @param evt
     */
    private void calculateMaxPathButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_calculateMaxPathButtonActionPerformed
	// TODO add your handling code here:
	String maxPath = calculateMaxPath(startVertexField.getText(), endVertexField.getText());

	JOptionPane.showMessageDialog(this, "Max path is: " + maxPath);
    }//GEN-LAST:event_calculateMaxPathButtonActionPerformed

    /**
     * Event handler for searchVertexField action performing
     * @param evt
     */
    private void endVertexFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_endVertexFieldActionPerformed
	// TODO add your handling code here:
	calculateMaxPathButtonActionPerformed(evt);
    }//GEN-LAST:event_endVertexFieldActionPerformed

    private void searchFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_searchFieldActionPerformed
	// TODO add your handling code here:
	searchButtonActionPerformed(evt);
    }//GEN-LAST:event_searchFieldActionPerformed

    private void searchButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_searchButtonActionPerformed
	// TODO add your handling code here:
	System.out.println("lalala!");
    }//GEN-LAST:event_searchButtonActionPerformed

    /**
     * Try to find largest path between pages
     * @param start name of the first page in path
     * @param end name of tha last page in path
     * @return max path length between start and end
     */
    private String calculateMaxPath(String start, String end) {
	// FIXME: TRUE GOvNOCODE
	File dir = new File(directory);

	String[] children = dir.list();

	Vector nodes = new Vector();
	Vector nodeWeights = new Vector();

	for (int i = 0; i < children.length; ++i) {
	    if (children[i].endsWith(".nothing")) {
		nodeWeights.addElement(0);
		nodes.addElement(children[i].substring(0, children[i].indexOf(".nothing")));
	    }
	}


	if (!nodes.contains(start) || !nodes.contains(end)) {
	    return "No path";
	}

	HashMap nodeConnections = new HashMap();

	for (int i = 0; i < nodes.size(); ++i) {

	    nodeConnections.put(nodes.elementAt(i), new Vector());

	    String nodeContents;
	    try {
		nodeContents = openFile((String) nodes.elementAt(i));
	    } catch (java.io.IOException e) {
		continue;
	    }

	    int searchStartPosition = 0;

	    while (nodeContents.indexOf("@link{", searchStartPosition) != -1) {
		int linkStart = nodeContents.indexOf("@link{", searchStartPosition) + 6;

		searchStartPosition = linkStart + 1;

		((Vector) nodeConnections.get(nodes.elementAt(i))).addElement(nodeContents.substring(linkStart, nodeContents.indexOf("}", linkStart)));
	    }
	}

	Graph graph = new Graph(nodes, nodeConnections);

	return graph.maxDistance(start, end);
    }

    /**
     * Change hypertext source location
     */
    private void changeLocation() {
	JFileChooser fc = new JFileChooser(directory);

	fc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);

	if (fc.showDialog(fc, "Choose") == JFileChooser.APPROVE_OPTION) {
	    directory = fc.getSelectedFile().toString();

	    openNothing("index");
	}
    }

    /**
     * Open file and return its contents as string
     * @param name name of the file
     * @return string file contents
     * @throws java.io.IOException
     */
    private String openFile(String name) throws java.io.IOException {
	StringBuffer fileData = new StringBuffer(1000);
	BufferedReader reader = new BufferedReader(new FileReader(directory
		+ File.separator + name + extension));
	char[] buf = new char[1024];
	int numRead = 0;
	while ((numRead = reader.read(buf)) != -1) {
	    String readData = String.valueOf(buf, 0, numRead);
	    fileData.append(readData);
	    buf = new char[1024];
	}
	reader.close();
	return fileData.toString();
    }

    /**
     * Open specified page in viewer as styled text
     * @param name name of the page
     */
    protected void openNothing(String name) {
	try {
	    this.doc.remove(0, doc.getLength());
	} catch (javax.swing.text.BadLocationException e) {
	}

	try {
	    String raw = this.openFile(name);

	    SimpleAttributeSet paragraphAttrs = new SimpleAttributeSet();

	    int position = 0;

	    while (position < raw.length()) {
		int noTagContentsStartPosition = position;
		boolean alignWasDeclared = false;
		while (position < raw.length()) {
		    if (raw.charAt(position) == '@') {
			break;
		    }
		    if (!alignWasDeclared) {
			if (raw.charAt(position) == '>') {
			    alignWasDeclared = true;
			    StyleConstants.setAlignment(paragraphAttrs, StyleConstants.ALIGN_RIGHT);
			} else if (raw.charAt(position) == '|') {
			    alignWasDeclared = true;
			    StyleConstants.setAlignment(paragraphAttrs, StyleConstants.ALIGN_JUSTIFIED);
			} else if (raw.charAt(position) == '^') {
			    alignWasDeclared = true;
			    StyleConstants.setAlignment(paragraphAttrs, StyleConstants.ALIGN_CENTER);
			} else if (raw.charAt(position) == '<') {
			    alignWasDeclared = true;
			    StyleConstants.setAlignment(paragraphAttrs, StyleConstants.ALIGN_LEFT);
			}

			if (alignWasDeclared) {
			    try {
				doc.insertString(doc.getLength(), raw.substring(noTagContentsStartPosition, position), null);
			    } catch (javax.swing.text.BadLocationException e) {
			    }

			    textPane.setParagraphAttributes(paragraphAttrs, true);

			    noTagContentsStartPosition = position + 1;
			}
		    } else {
			alignWasDeclared = false;
		    }
		    ++position;
		}

		try {
		    doc.insertString(doc.getLength(), raw.substring(noTagContentsStartPosition, position), null);
		} catch (javax.swing.text.BadLocationException e) {
		}

		if (position < raw.length()) {
		    String tagName = "";
		    ++position;
		    int tagStartPosition = position;
		    while (position < raw.length()) {
			if (raw.charAt(position) == '{') {
			    tagName = raw.substring(tagStartPosition, position);
			    break;
			}
			++position;
		    }

		    if (!tagName.equals("") && position < raw.length()) {
			String tagContents;
			++position;
			int tagContentsStartPosition = position;
			while (position < raw.length()) {
			    if (raw.charAt(position) == '}') {
				tagContents = raw.substring(tagContentsStartPosition, position);

				this.insertTag(tagName, tagContents);

				break;
			    }
			    ++position;
			}
		    }
		}
		++position;
	    }
	} catch (java.io.IOException e) {
	    JOptionPane.showMessageDialog(this, "Probably broken link: " + name);
	}

	textPane.setCaretPosition(0);
    }

    /**
     * Insert formatted tag contents into views
     * @param tagName name of the tag to apply
     * @param tagContents text to apply text to
     */
    private void insertTag(String tagName, String tagContents) {
	SimpleAttributeSet attr = new SimpleAttributeSet();

	if (tagName.equals("link")) {
	    StyleConstants.setBackground(attr, linkStyleValue);
	} else if (tagName.startsWith("highlight")) {
	    // 9 == length of 'color' string
	    if (tagName.indexOf("_") == 9) {
		String colorName = tagName.substring(10);
		Color color;
		if (colorName.equals("pink")) {
		    color = Color.pink;
		} else if (colorName.equals("yellow")) {
		    color = Color.yellow;
		} else if (colorName.equals("blue")) {
		    color = Color.blue;
		} else if (colorName.equals("green")) {
		    color = Color.green;
		} else {
		    color = Color.white;
		}
		StyleConstants.setBackground(attr, color);
	    }
	} else if (tagName.equals("big_heading")) {
	    StyleConstants.setFontSize(attr, 24);
	} else if (tagName.equals("medium_heading")) {
	    StyleConstants.setFontSize(attr, 22);
	} else if (tagName.equals("regular_heading")) {
	    StyleConstants.setFontSize(attr, 16);
	} else if (tagName.equals("image")) {
	    StyleConstants.setIcon(attr, new ImageIcon(directory + File.separator + tagContents));
	} else if (tagName.equals("bold")) {
	    StyleConstants.setBold(attr, true);
	} else if (tagName.equals("italic")) {
	    StyleConstants.setItalic(attr, true);
	} else if (tagName.equals("strike")) {
	    StyleConstants.setStrikeThrough(attr, true);
	} else if (tagName.equals("subscript")) {
	    StyleConstants.setSubscript(attr, true);
	} else if (tagName.equals("superscript")) {
	    StyleConstants.setSuperscript(attr, true);
	} else if (tagName.equals("underline")) {
	    StyleConstants.setUnderline(attr, true);
	} else if (tagName.equals("polina")) {
	    StyleConstants.setBackground(attr, Color.pink);
	} else if (tagName.equals("ololo")) {
	    StyleConstants.setForeground(attr, Color.green);
	    tagContents = "ololo: " + tagContents;
	} else if (tagName.equals("irony")) {
	    StyleConstants.setForeground(attr, Color.gray);
	    StyleConstants.setItalic(attr, true);
	} else if (tagName.startsWith("color")) {
	    // 5 == length of 'color' string
	    if (tagName.indexOf("_") == 5) {
		String colorName = tagName.substring(6);
		Color color;
		if (colorName.equals("red")) {
		    color = Color.red;
		} else if (colorName.equals("yellow")) {
		    color = Color.yellow;
		} else if (colorName.equals("blue")) {
		    color = Color.blue;
		} else if (colorName.equals("green")) {
		    color = Color.green;
		} else {
		    color = Color.black;
		}
		StyleConstants.setForeground(attr, color);
	    }
	} else if (tagName.equals("CAPSLOCK")) {
	    tagContents = tagContents.toUpperCase();
	} else if (tagName.startsWith("fontfamily")) {
	    if (tagName.indexOf("_") == 10) {
		String fontFamilyName = tagName.substring(11).replace("_", " ");
		StyleConstants.setFontFamily(attr, fontFamilyName);
	    }
	}

	try {
	    doc.insertString(doc.getLength(), tagContents, attr);
	} catch (javax.swing.text.BadLocationException e) {
	}
    }

    protected HashMap<String, Integer> readMystemOutput(String input) throws IOException
    {
	HashMap<String, Integer> words = new HashMap<String, Integer>();

	File tempFile = File.createTempFile("hypernoting", ".tmp");

	BufferedWriter out = new BufferedWriter(new FileWriter(tempFile));
	out.write("мамы в выборге мыли раму карокадыбры!");
	out.close();

	Process p = Runtime.getRuntime().exec("./mystem -n -e utf8 "+tempFile.getAbsolutePath());

	BufferedReader stdInput = new BufferedReader(new InputStreamReader(p.getInputStream()));

	String line = null;
	while ((line = stdInput.readLine()) != null)
	{
	    int position = 0;
	    while (position < line.length())
	    {
		if (line.charAt(position) == '{')
		{
		    break;
		}
		++position;
	    }
	    ++position;
	    String word = "";
	    while (position < line.length() && line.charAt(position) != '}')
	    {
		if (line.charAt(position) == '|')
		{
		    if (!words.containsKey(word))
		    {
			words.put(word, 1);
		    } else
		    {
			words.put(word, words.get(word)+1);
		    }
		    word = "";
		} else
		{
		    word += line.charAt(position);
		}

		++position;
	    }
	    System.out.println(line);
	}

	return words;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
	java.awt.EventQueue.invokeLater(new Runnable() {

	    public void run() {



		new HyperNothingGUI().setVisible(true);
	    }
	});
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton calculateMaxPathButton;
    private javax.swing.JButton changeLocationButton;
    private javax.swing.JTextField endVertexField;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JScrollPane scrollPane;
    private javax.swing.JButton searchButton;
    private javax.swing.JTextField searchField;
    private javax.swing.JTextField startVertexField;
    private javax.swing.JTextPane textPane;
    private javax.swing.JLabel verticesLabel;
    // End of variables declaration//GEN-END:variables
}
